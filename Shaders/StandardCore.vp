in HIGHP vec4 in_position   : POSITION;
in LOWP vec3 in_normal      : NORMAL;
in LOWP vec4 in_color       : COLOR;
in MEDIUMP vec2 in_st       : TEXCOORD0;

#if _NORMAL != 0
    in LOWP vec4 in_tangent : TANGENT;
#endif

#ifdef USE_SHADOW_MAP
$include "ShadowLibrary.vp"
#endif

out LOWP vec4 v2f_color;
out MEDIUMP vec2 v2f_tex;

#if _NORMAL == 0
    out LOWP vec3 v2f_normal;
#endif

#ifdef DIRECT_LIGHTING
    out vec3 v2f_lightVector;
    out vec3 v2f_lightFallOff;
    out vec4 v2f_lightProjection;
#endif

#ifdef INDIRECT_LIGHTING
    out vec4 v2f_toWorldAndPackedWorldPosS;
    out vec4 v2f_toWorldAndPackedWorldPosT;
    out vec4 v2f_toWorldAndPackedWorldPosR;
#endif

#if defined(INDIRECT_LIGHTING) || defined(DIRECT_LIGHTING) || _PARALLAX != 0
    out vec3 v2f_viewVector;
#endif

#ifdef INSTANCING
    struct InstanceData {
        vec4 worldMatrixS;
        vec4 worldMatrixT;
        vec4 worldMatrixR;
        vec4 worldMatrixInvS;
        vec4 worldMatrixInvT;
        vec4 worldMatrixInvR;
    };

    UNIFORM_BLOCK InstanceDataBlock {
        InstanceData instanceData[512];
    };

    #define instance instanceData[gl_InstanceID]
#else
    uniform vec4 worldMatrixS;
    uniform vec4 worldMatrixT;
    uniform vec4 worldMatrixR;
    uniform vec4 worldMatrixInvS;
    uniform vec4 worldMatrixInvT;
    uniform vec4 worldMatrixInvR;
    uniform vec4 textureMatrixS;
    uniform vec4 textureMatrixT;
    uniform vec3 viewOrigin;
    uniform vec4 lightVec;
    uniform LOWP vec4 vertexColorScale;
    uniform LOWP vec4 vertexColorAdd;
    uniform LOWP vec4 constantColor;
#endif

uniform mat4 viewProjectionMatrix;
uniform mat4 modelViewProjectionMatrix;
uniform vec3 lightInvRadius;
uniform mat4 lightTextureMatrix;
uniform bool useShadowMap;

void main() {
#if _NORMAL == 0
    vec4 localPos;
    vec3 localNormal;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
    #endif
    
    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal);
    #else
        localPos = in_position;
        localNormal = vNormal;
    #endif
#else
    vec4 localPos;
    vec3 localNormal;
    vec3 localTangent;
    vec3 localBiTangent;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
        vec4 vTangent = in_tangent * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
        vec4 vTangent = in_tangent;
    #endif

    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal, vTangent, localTangent, localBiTangent);
    #else
        localPos = in_position;
        localNormal = vNormal;
        localTangent = vTangent.xyz;
        localBiTangent = normalize(cross(vNormal, vTangent.xyz) * vTangent.w);
    #endif
#endif

    vec4 worldPos;
    worldPos.x = dot(worldMatrixS, localPos);
    worldPos.y = dot(worldMatrixT, localPos);
    worldPos.z = dot(worldMatrixR, localPos);
    worldPos.w = 1.0;

#ifdef DIRECT_LIGHTING
    vec3 worldL = lightVec.xyz - lightVec.w * worldPos.xyz;

    #ifdef USE_SHADOW_MAP
        #ifdef USE_SHADOW_POINT
            ShadowCubeTransform(worldL);
        #elif defined(USE_SHADOW_SPOT) || defined(USE_SHADOW_CASCADE)
            ShadowTransform(worldPos);
        #endif
    #endif

    v2f_lightProjection = lightTextureMatrix * worldPos;
    v2f_lightFallOff = worldL * lightInvRadius;
#endif

#if _NORMAL == 0
    #if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING) || _PARALLAX != 0
        v2f_normal = localNormal;

        vec3 worldV = viewOrigin.xyz - worldPos.xyz;
        vec3 localV;
        localV.x = dot(worldMatrixInvS.xyz, worldV);
        localV.y = dot(worldMatrixInvT.xyz, worldV);
        localV.z = dot(worldMatrixInvR.xyz, worldV);

        v2f_viewVector = localV;
    #endif

    #ifdef DIRECT_LIGHTING
        vec3 localL;
        localL.x = dot(worldMatrixInvS.xyz, worldL);
        localL.y = dot(worldMatrixInvT.xyz, worldL);
        localL.z = dot(worldMatrixInvR.xyz, worldL);

        v2f_lightVector = localL;
    #endif
   
    #ifdef INDIRECT_LIGHTING
        v2f_toWorldAndPackedWorldPosS.xyz = worldMatrixS.xyz;
        v2f_toWorldAndPackedWorldPosT.xyz = worldMatrixT.xyz;
        v2f_toWorldAndPackedWorldPosR.xyz = worldMatrixR.xyz;

        v2f_toWorldAndPackedWorldPosS.w = worldPos.x;
        v2f_toWorldAndPackedWorldPosT.w = worldPos.y;
        v2f_toWorldAndPackedWorldPosR.w = worldPos.z;
    #endif
#else
    #if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING) || _PARALLAX != 0
        mat3 TBN = mat3(localTangent, localBiTangent, localNormal);

        vec3 worldV = viewOrigin.xyz - worldPos.xyz;
        vec3 localV;
        localV.x = dot(worldMatrixInvS.xyz, worldV);
        localV.y = dot(worldMatrixInvT.xyz, worldV);
        localV.z = dot(worldMatrixInvR.xyz, worldV);

        v2f_viewVector = localV * TBN;
    #endif

    #ifdef DIRECT_LIGHTING
        vec3 localL;
        localL.x = dot(worldMatrixInvS.xyz, worldL);
        localL.y = dot(worldMatrixInvT.xyz, worldL);
        localL.z = dot(worldMatrixInvR.xyz, worldL);

        v2f_lightVector = localL * TBN;
    #endif
    
    #ifdef INDIRECT_LIGHTING
        v2f_toWorldAndPackedWorldPosS.xyz = worldMatrixS.xyz * TBN;
        v2f_toWorldAndPackedWorldPosT.xyz = worldMatrixT.xyz * TBN;
        v2f_toWorldAndPackedWorldPosR.xyz = worldMatrixR.xyz * TBN;
        //v2f_toWorldAndPackedWorldPosT.w = in_tangent.w;

        v2f_toWorldAndPackedWorldPosS.w = worldPos.x;
        v2f_toWorldAndPackedWorldPosT.w = worldPos.y;
        v2f_toWorldAndPackedWorldPosR.w = worldPos.z;
    #endif
#endif

    v2f_tex.s = dot(textureMatrixS, vec4(in_st, 0.0, 1.0));
    v2f_tex.t = dot(textureMatrixT, vec4(in_st, 0.0, 1.0));

#ifdef LIGHTMAP
    v2f_tex.rq = in_st2.st;
#endif

    v2f_color = (in_color * vertexColorScale + vertexColorAdd) * constantColor;

#ifdef INSTANCING
    gl_Position = viewProjectionMatrix * worldPos;
#else
    gl_Position = modelViewProjectionMatrix * localPos;
#endif
}
