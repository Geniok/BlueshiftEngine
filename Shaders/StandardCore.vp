in HIGHP vec4 in_position : POSITION;
in MEDIUMP vec2 in_st : TEXCOORD0;
in LOWP vec4 in_tangent : TEXCOORD1;
in LOWP vec4 in_color : COLOR;
in LOWP vec3 in_normal : NORMAL;

#ifdef USE_SHADOW_MAP
$include "ShadowLibrary.vp"
#endif

out LOWP vec4 v2f_color;
out MEDIUMP vec2 v2f_tex;

#if _NORMAL == 0
    out LOWP vec3 v2f_normal;
#endif

#ifdef DIRECT_LIGHTING
    out vec3 v2f_lightVector;
    out vec3 v2f_lightFallOff;
    out vec4 v2f_lightProjection;
#endif

#ifdef INDIRECT_LIGHTING
    out vec4 v2f_toWorldAndPackedWorldPosS;
    out vec4 v2f_toWorldAndPackedWorldPosT;
    out vec4 v2f_toWorldAndPackedWorldPosR;
#endif

#if defined(INDIRECT_LIGHTING) || defined(DIRECT_LIGHTING) || _PARALLAX != 0
    out vec3 v2f_viewVector;
#endif

#ifdef INSTANCING
    struct InstanceData {
        vec4 worldMatrixS;
        vec4 worldMatrixT;
        vec4 worldMatrixR;
        vec3 localViewOrigin;
        mat3 localLightAxis;
        vec4 localLightOrigin;
        LOWP vec4 constantColor;
    };

    UNIFORM_BLOCK InstanceDataBlock {
        InstanceData instanceData[256];
    };

    #define instance instanceData[gl_InstanceID]
#else
    uniform vec4 worldMatrixS;
    uniform vec4 worldMatrixT;
    uniform vec4 worldMatrixR;
    uniform vec4 textureMatrixS;
    uniform vec4 textureMatrixT;
    uniform vec3 localViewOrigin;
    uniform mat3 localLightAxis;
    uniform vec4 localLightOrigin;
    uniform LOWP vec4 vertexColorScale;
    uniform LOWP vec4 vertexColorAdd;
    uniform LOWP vec4 constantColor;
#endif

uniform mat4 viewProjectionMatrix;
uniform mat4 modelViewProjectionMatrix;
uniform vec3 lightInvRadius;
uniform mat4 lightTextureMatrix;
uniform bool useShadowMap;

void main() {
#if _NORMAL == 0
    vec4 localPos;
    vec3 localNormal;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
    #endif
    
    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal);
    #else
        localPos = in_position;
        localNormal = vNormal;
    #endif
#else
    vec4 localPos;
    vec3 localNormal;
    vec3 localTangent;
    vec3 localBiTangent;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
        vec4 vTangent = in_tangent * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
        vec4 vTangent = in_tangent;
    #endif

    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal, vTangent, localTangent, localBiTangent);
    #else
        localPos = in_position;
        localNormal = vNormal;
        localTangent = vTangent.xyz;
        localBiTangent = normalize(cross(vNormal, vTangent.xyz) * vTangent.w);
    #endif
#endif

#if defined(INDIRECT_LIGHTING) || defined(DIRECT_LIGHTING)
    vec4 worldPos;
    worldPos.x = dot(worldMatrixS, localPos);
    worldPos.y = dot(worldMatrixT, localPos);
    worldPos.z = dot(worldMatrixR, localPos);
    worldPos.w = 1.0;
    #define WORLD_POS_CALCULATED
#endif

#ifdef DIRECT_LIGHTING
    #ifdef USE_SHADOW_MAP
        #ifdef USE_SHADOW_POINT
            ShadowCubeTransform(localPos, localLightOrigin.xyz, worldMatrixS.xyz, worldMatrixT.xyz, worldMatrixR.xyz);
        #elif defined(USE_SHADOW_SPOT) || defined(USE_SHADOW_CASCADE)
            ShadowTransform(worldPos);
        #endif
    #endif
    
    v2f_lightProjection = lightTextureMatrix * worldPos;

    vec3 L = localLightOrigin.xyz + (localLightOrigin.w - 1.0) * localPos.xyz;

    v2f_lightFallOff = (L * localLightAxis) * lightInvRadius;
#endif

#if _NORMAL == 0
    #if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING) || _PARALLAX != 0
        v2f_normal = localNormal;

        v2f_viewVector = localViewOrigin.xyz - localPos.xyz;
    #endif

    #ifdef DIRECT_LIGHTING
        v2f_lightVector = L;
    #endif
   
    #ifdef INDIRECT_LIGHTING
        v2f_toWorldAndPackedWorldPosS.xyz = worldMatrixS.xyz;
        v2f_toWorldAndPackedWorldPosT.xyz = worldMatrixT.xyz;
        v2f_toWorldAndPackedWorldPosR.xyz = worldMatrixR.xyz;

        v2f_toWorldAndPackedWorldPosS.w = worldPos.x;
        v2f_toWorldAndPackedWorldPosT.w = worldPos.y;
        v2f_toWorldAndPackedWorldPosR.w = worldPos.z;
    #endif
#else
    #if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING) || _PARALLAX != 0
        mat3 TBN = mat3(localTangent, localBiTangent, localNormal);

        v2f_viewVector = (localViewOrigin.xyz - localPos.xyz) * TBN;
    #endif

    #ifdef DIRECT_LIGHTING
        v2f_lightVector = L * TBN;
    #endif
    
    #ifdef INDIRECT_LIGHTING
        v2f_toWorldAndPackedWorldPosS.xyz = worldMatrixS.xyz * TBN;
        v2f_toWorldAndPackedWorldPosT.xyz = worldMatrixT.xyz * TBN;
        v2f_toWorldAndPackedWorldPosR.xyz = worldMatrixR.xyz * TBN;
        //v2f_toWorldAndPackedWorldPosT.w = in_tangent.w;

        v2f_toWorldAndPackedWorldPosS.w = worldPos.x;
        v2f_toWorldAndPackedWorldPosT.w = worldPos.y;
        v2f_toWorldAndPackedWorldPosR.w = worldPos.z;
    #endif
#endif

    v2f_tex.s = dot(textureMatrixS, vec4(in_st, 0.0, 1.0));
    v2f_tex.t = dot(textureMatrixT, vec4(in_st, 0.0, 1.0));

#ifdef LIGHTMAP
    v2f_tex.rq = in_st2.st;
#endif

    v2f_color = (in_color * vertexColorScale + vertexColorAdd) * constantColor;

#ifdef INSTANCING
    #ifndef WORLD_POS_CALCULATED
        vec4 worldPos;
        worldPos.x = dot(worldMatrixS, localPos);
        worldPos.y = dot(worldMatrixT, localPos);
        worldPos.z = dot(worldMatrixR, localPos);
        worldPos.w = 1.0;
    #endif
    gl_Position = viewProjectionMatrix * worldPos;
#else
    gl_Position = modelViewProjectionMatrix * localPos;
#endif
}
