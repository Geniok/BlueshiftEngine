#if _ALBEDO != 0 || _NORMAL != 0 || _SPECULAR != 0 || _GLOSS == 3 || _METALLIC >= 1 || (_ROUGHNESS == 1 || _ROUGHNESS == 2) || _PARALLAX != 0 || _EMISSION == 2 || _CLEARCOAT == 2 || (_CLEARCOAT != 0 && _CC_NORMAL == 1) || _ANISO == 2 || _OCC == 1
    #define NEED_BASE_TC
#endif

in HIGHP vec4 in_position   : POSITION;
in LOWP vec3 in_normal      : NORMAL;
in LOWP vec4 in_color       : COLOR;
in MEDIUMP vec2 in_st       : TEXCOORD0;

#if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
    in LOWP vec4 in_tangent : TANGENT;
#endif

out VS_OUT {
    LOWP vec4 color;

#ifdef NEED_BASE_TC
    MEDIUMP vec2 tex;
#endif

#if _NORMAL == 0
    LOWP vec3 normal;
#endif

#if _PARALLAX
    vec3 tangentViewDir;
#endif

#ifdef DIRECT_LIGHTING
    vec3 lightVector;
    vec3 lightFallOff;
    vec4 lightProjection;
#endif

#if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING)
    vec3 viewVector;

    #if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
        vec4 tangentToWorldAndPackedWorldPosS;
        vec4 tangentToWorldAndPackedWorldPosT;
        vec4 tangentToWorldAndPackedWorldPosR;
    #else
        vec3 worldPos;
    #endif
#endif
} vs_out;

#ifdef USE_SHADOW_MAP
    $include "ShadowLibrary.vp"
#endif

#if defined(INSTANCING)
    $include "Instancing.vp"
#else
    uniform mat4x3 localToWorldMatrix;
    uniform mat3 worldToLocalMatrix;
    uniform LOWP vec4 constantColor;
#endif

#ifdef GPU_SKINNING
    #if defined(GPU_SKINNING_1_WEIGHTS)
        $include "SkinningMatrix1.glsl"
    #elif defined(GPU_SKINNING_4_WEIGHTS)
        $include "SkinningMatrix4.glsl"
    #elif defined(GPU_SKINNING_8_WEIGHTS)
        $include "SkinningMatrix8.glsl"
    #endif
#endif

uniform vec4 textureMatrixS;
uniform vec4 textureMatrixT;
uniform LOWP vec4 vertexColorScale;
uniform LOWP vec4 vertexColorAdd;

uniform vec3 viewOrigin;                // eye position in world space
uniform vec4 lightVec;                  // light position or light direction in world space
uniform mat4 viewProjectionMatrix;
uniform mat4 modelViewProjectionMatrix;
uniform vec3 lightInvRadius;
uniform mat4x3 lightFallOffMatrix;
uniform mat4 lightTextureMatrix;
uniform bool useShadowMap;

void main() {
#if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
    vec4 localPos;
    vec3 localNormal;
    vec3 localTangent;
    vec3 localBiTangent;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
        vec4 vTangent = in_tangent * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
        vec4 vTangent = in_tangent;
    #endif

    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal, vTangent, localTangent, localBiTangent);
    #else
        localPos = in_position;
        localNormal = vNormal;
        localTangent = vTangent.xyz;
        localBiTangent = normalize(cross(vNormal, vTangent.xyz) * vTangent.w);
    #endif
#else
    vec4 localPos;
    vec3 localNormal;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
    #endif
    
    #ifdef GPU_SKINNING
        skinningMatrix(in_position, localPos, vNormal, localNormal);
    #else
        localPos = in_position;
        localNormal = vNormal;
    #endif
#endif

    vec4 worldPos = vec4(localToWorldMatrix * localPos, 1.0);

#if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING)
    vec3 worldV = viewOrigin.xyz - worldPos.xyz;

    vs_out.viewVector = worldV;

    #if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
        #if _PARALLAX
            vec3 localV = worldToLocalMatrix * worldV;

            vs_out.tangentViewDir.x = dot(localTangent, localV);
            vs_out.tangentViewDir.y = dot(localBiTangent, localV);
            vs_out.tangentViewDir.z = dot(localNormal, localV);
        #endif

        // Build the matrix to transform tangent space into GL world space
        vs_out.tangentToWorldAndPackedWorldPosS.xyz = localToWorldMatrix * vec4(localTangent, 0.0);
        vs_out.tangentToWorldAndPackedWorldPosT.xyz = localToWorldMatrix * vec4(localBiTangent, 0.0);
        vs_out.tangentToWorldAndPackedWorldPosR.xyz = localToWorldMatrix * vec4(localNormal, 0.0);

        #ifdef INDIRECT_LIGHTING
            vs_out.tangentToWorldAndPackedWorldPosS.w = worldPos.x;
            vs_out.tangentToWorldAndPackedWorldPosT.w = worldPos.y;
            vs_out.tangentToWorldAndPackedWorldPosR.w = worldPos.z;
        #endif 
    #else
        vs_out.normal = localToWorldMatrix * vec4(localNormal, 0.0);

        vs_out.worldPos = worldPos.xyz;
    #endif
#endif

#ifdef DIRECT_LIGHTING
    // Light direction in world space
    vec3 worldL = lightVec.xyz - lightVec.w * worldPos.xyz;

    #ifdef USE_SHADOW_MAP
        #ifdef USE_SHADOW_POINT
            ShadowCubeTransform(worldL);
        #elif defined(USE_SHADOW_SPOT) || defined(USE_SHADOW_CASCADE)
            ShadowTransform(worldPos);
        #endif
    #endif

    vs_out.lightVector = worldL;
    vs_out.lightProjection = lightTextureMatrix * worldPos;
    vs_out.lightFallOff = lightFallOffMatrix * worldPos;
#endif

#ifdef NEED_BASE_TC
    vs_out.tex.s = dot(textureMatrixS, vec4(in_st, 0.0, 1.0));
    vs_out.tex.t = dot(textureMatrixT, vec4(in_st, 0.0, 1.0));
#endif

#ifdef LIGHTMAP
    vs_out.tex.rq = in_st2.st;
#endif

    vs_out.color = (in_color * vertexColorScale + vertexColorAdd) * constantColor;

#ifdef INSTANCING
    gl_Position = viewProjectionMatrix * worldPos;
#else
    gl_Position = modelViewProjectionMatrix * localPos;
#endif
}
